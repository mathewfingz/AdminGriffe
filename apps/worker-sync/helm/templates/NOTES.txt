1. Get the application URL by running these commands:
{{- if .Values.ingress.enabled }}
{{- range $host := .Values.ingress.hosts }}
  {{- range .paths }}
  http{{ if $.Values.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}
  {{- end }}
{{- end }}
{{- else if contains "NodePort" .Values.service.type }}
  export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ include "worker-sync.fullname" . }})
  export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT
{{- else if contains "LoadBalancer" .Values.service.type }}
     NOTE: It may take a few minutes for the LoadBalancer IP to be available.
           You can watch the status of by running 'kubectl get --namespace {{ .Release.Namespace }} svc -w {{ include "worker-sync.fullname" . }}'
  export SERVICE_IP=$(kubectl get svc --namespace {{ .Release.Namespace }} {{ include "worker-sync.fullname" . }} --template "{{"{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}"}}")
  echo http://$SERVICE_IP:{{ .Values.service.port }}
{{- else if contains "ClusterIP" .Values.service.type }}
  export POD_NAME=$(kubectl get pods --namespace {{ .Release.Namespace }} -l "app.kubernetes.io/name={{ include "worker-sync.name" . }},app.kubernetes.io/instance={{ .Release.Name }}" -o jsonpath="{.items[0].metadata.name}")
  export CONTAINER_PORT=$(kubectl get pod --namespace {{ .Release.Namespace }} $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace {{ .Release.Namespace }} port-forward $POD_NAME 8080:$CONTAINER_PORT
{{- end }}

2. Monitor the application:
{{- if .Values.prometheus.enabled }}
  Prometheus: 
  {{- if .Values.prometheus.ingress.enabled }}
  {{- range $host := .Values.prometheus.ingress.hosts }}
    {{- range .paths }}
    http{{ if $.Values.prometheus.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}
    {{- end }}
  {{- end }}
  {{- else }}
  kubectl --namespace {{ .Release.Namespace }} port-forward svc/{{ include "worker-sync.fullname" . }}-prometheus 9090:9090
  {{- end }}
{{- end }}

{{- if .Values.grafana.enabled }}
  Grafana:
  {{- if .Values.grafana.ingress.enabled }}
  {{- range $host := .Values.grafana.ingress.hosts }}
    {{- range .paths }}
    http{{ if $.Values.grafana.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}
    {{- end }}
  {{- end }}
  {{- else }}
  kubectl --namespace {{ .Release.Namespace }} port-forward svc/{{ include "worker-sync.fullname" . }}-grafana 3000:3000
  {{- end }}
  
  Default credentials:
  Username: admin
  Password: {{ .Values.grafana.adminPassword | default "admin" }}
{{- end }}

{{- if .Values.alertmanager.enabled }}
  AlertManager:
  {{- if .Values.alertmanager.ingress.enabled }}
  {{- range $host := .Values.alertmanager.ingress.hosts }}
    {{- range .paths }}
    http{{ if $.Values.alertmanager.ingress.tls }}s{{ end }}://{{ $host.host }}{{ .path }}
    {{- end }}
  {{- end }}
  {{- else }}
  kubectl --namespace {{ .Release.Namespace }} port-forward svc/{{ include "worker-sync.fullname" . }}-alertmanager 9093:9093
  {{- end }}
{{- end }}

3. Check application status:
  kubectl --namespace {{ .Release.Namespace }} get pods -l "app.kubernetes.io/name={{ include "worker-sync.name" . }},app.kubernetes.io/instance={{ .Release.Name }}"

4. View application logs:
  kubectl --namespace {{ .Release.Namespace }} logs -f deployment/{{ include "worker-sync.fullname" . }}

5. Health checks:
  Health endpoint: /health
  Metrics endpoint: /metrics
  Ready endpoint: /ready

6. Database connections:
{{- if .Values.databases.postgresql.enabled }}
  PostgreSQL: {{ .Values.databases.postgresql.host }}:{{ .Values.databases.postgresql.port }}/{{ .Values.databases.postgresql.database }}
{{- end }}
{{- if .Values.databases.mysql.enabled }}
  MySQL: {{ .Values.databases.mysql.host }}:{{ .Values.databases.mysql.port }}/{{ .Values.databases.mysql.database }}
{{- end }}
{{- if .Values.databases.mongodb.enabled }}
  MongoDB: {{ .Values.databases.mongodb.host }}:{{ .Values.databases.mongodb.port }}/{{ .Values.databases.mongodb.database }}
{{- end }}

7. Message queues:
{{- if .Values.kafka.enabled }}
  Kafka: {{ .Values.kafka.brokers }}
{{- end }}
{{- if .Values.rabbitmq.enabled }}
  RabbitMQ: {{ .Values.rabbitmq.host }}:{{ .Values.rabbitmq.port }}
{{- end }}

8. Cache:
{{- if .Values.redis.enabled }}
  Redis: {{ .Values.redis.host }}:{{ .Values.redis.port }}
{{- end }}

9. Useful commands:
  # Scale the application
  kubectl --namespace {{ .Release.Namespace }} scale deployment {{ include "worker-sync.fullname" . }} --replicas=<number>
  
  # Update configuration
  helm upgrade {{ .Release.Name }} ./helm --namespace {{ .Release.Namespace }} -f values.yaml
  
  # View sync status
  kubectl --namespace {{ .Release.Namespace }} exec -it deployment/{{ include "worker-sync.fullname" . }} -- npm run sync:status
  
  # Trigger manual sync
  kubectl --namespace {{ .Release.Namespace }} exec -it deployment/{{ include "worker-sync.fullname" . }} -- npm run sync:manual
  
  # View audit logs
  kubectl --namespace {{ .Release.Namespace }} exec -it deployment/{{ include "worker-sync.fullname" . }} -- npm run audit:logs

{{- if .Values.cronJobs.backup.enabled }}
10. Backup information:
  Backup schedule: {{ .Values.cronJobs.backup.schedule }}
  Retention: {{ .Values.cronJobs.backup.retentionDays }} days
  {{- if .Values.cronJobs.backup.s3.enabled }}
  S3 Bucket: {{ .Values.cronJobs.backup.s3.bucket }}
  {{- end }}
  
  # Manual backup
  kubectl --namespace {{ .Release.Namespace }} create job --from=cronjob/{{ include "worker-sync.fullname" . }}-backup manual-backup-$(date +%s)
{{- end }}

{{- if .Values.autoscaling.enabled }}
11. Autoscaling:
  Min replicas: {{ .Values.autoscaling.minReplicas }}
  Max replicas: {{ .Values.autoscaling.maxReplicas }}
  Target CPU: {{ .Values.autoscaling.targetCPUUtilizationPercentage }}%
  {{- if .Values.autoscaling.targetMemoryUtilizationPercentage }}
  Target Memory: {{ .Values.autoscaling.targetMemoryUtilizationPercentage }}%
  {{- end }}
{{- end }}

{{- if .Values.networkPolicy.enabled }}
12. Network Security:
  Network policies are enabled for enhanced security.
  Only allowed traffic can reach the application.
{{- end }}

{{- if .Values.podDisruptionBudget.enabled }}
13. High Availability:
  Pod Disruption Budget is configured to ensure availability during updates.
  {{- if .Values.podDisruptionBudget.minAvailable }}
  Minimum available pods: {{ .Values.podDisruptionBudget.minAvailable }}
  {{- else }}
  Maximum unavailable pods: {{ .Values.podDisruptionBudget.maxUnavailable }}
  {{- end }}
{{- end }}

For more information, visit: https://github.com/your-org/worker-sync